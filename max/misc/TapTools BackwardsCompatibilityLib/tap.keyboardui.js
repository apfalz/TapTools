/*Keyboard selection unit.Add optional # of Octaves, better highlighting, fix black key pixel velocity.*/outlets = 3;inlets = 3;// CONSTANTSconst KEYBOARDUI_VERSION = 2;const KEYSLIDER_VERSION = 1.0;const BLACK_KEY_PIXEL_HEIGHT = 19;const KEY_PIXEL_WIDTH = 9;const NUM_PITCHES = 16;sketch.default2d();var val = 0;var vbrgb = [1.,1.,1.,1.];			// Background Colorvar vfrgb = [0.2,0.2,0.2,1.];		// var vrgb2 = [0.7,0.5,0.5,1.];		// Ball indicator Colorvar boxWidth = box.rect[2] - box.rect[0];		// pixel width and height of windowvar boxHeight = box.rect[3] - box.rect[1];var aspect = boxWidth / boxHeight;var pitchA = [0,0,1,1,2,3,3,4,4,5,5,6,6,7,8,8,9,10,10,11,11];						// each key in 3rds, which note is clicked on top half of keyboardvar pitchB = [0,2,4,5,7,9,11];														// which note is clicked in bottom half of keyboardvar pixelShift = [4.5,KEY_PIXEL_WIDTH,13.5,18,22.5,31.5,36,40.5,45,49.5,54,59.5];	// shift in pixels of a key within the octavevar blackOrWhite = [-0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,0.5,-0.5];     	// height of key depressed highlightvar selected = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];					// 16 available pitchesvar selectedYValue = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];				// corresponding amplitudes// var lastSelected = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];var selectPointer = 0;												// which value of selected[] is going to be changed				// Imagevar img = new Image("tap.keyboardui.tif");		// one octave of the keyboard each key divisible in 3rds.var pic_halfWidth = img.size[0] / 2;			// used for centering the imagevar pic_halfHeight = img.size[1] / 2;var numOctaves = 5;			// default 5 octavesvar keyOffset = 24;			// added to the base key #, 24 = 2 octaves// process argumentsif (jsarguments.length>1)	numOctaves = jsarguments[1];if (jsarguments.length>2)	keyOffset = jsarguments[2];const HIGHEST_PITCH = (keyOffset + (numOctaves * 12));box.size((img.size[0] * numOctaves),img.size[1]);		// Constrain window to image sizedraw();function draw(){	var x = [0.5,0];	var keysOver = 0;	var octaveOffset = 0;	var pixelsOver = 0;	var worldBallHeight = -0.5;	with (sketch) {		// erase background		glclearcolor(vbrgb[0],vbrgb[1],vbrgb[2],vbrgb[3]);		glclear();							for (i=0; i< numOctaves; i++) {			copypixels(img, (i * img.size[0]), 0);		// draw Keyboard		}				glcolor(vrgb2);				for (i = 0; i < NUM_PITCHES; i ++) {			// Draw Ball indicators			if (selected[i] != 0) {				octaveOffset = Math.floor((selected[i] - keyOffset) / 12);		// number of octaves				keysOver = ((selected[i] - keyOffset) - (octaveOffset * 12));		// number of keys in the last octave								pixelsOver = pixelShift[keysOver] + (octaveOffset * img.size[0]);  // pixels for the octave shift + number of pixels within 1 octave.				worldBallHeight = blackOrWhite[keysOver];				// choose y value depending on which key is depressed								x = screentoworld(pixelsOver, 0);				moveto(x[0] , worldBallHeight);				sphere(0.15);			}		}	}	}draw.local = 1;function bang(){	draw();	refresh();														// output changed value only	outlet(0, selectPointer, selected[selectPointer], selectedYValue[selectPointer]);	outlet(1, selected);	outlet(2, selectedYValue);		notifyclients();}function sendOut(){										// output changed value only	outlet(0, selectPointer, selected[selectPointer], selectedYValue[selectPointer]);}sendOut.local = 1;function msg_float(v){	val = Math.min(Math.max(0,v),1);	notifyclients();	bang();}function list(){	if (inlet == 0) {							// **** Set single Pitch & Amplitude ****//		for (i = 0; i < NUM_PITCHES; i++) {		// search 16 selections to see if one is on			if (selected[i] == arguments[0]) {				selected[i] = 0;		// turn it off				selectedYValue[i] = 0.;				selectPointer = i;		// sets last selected to be overwritten if there are no 0's available				zero = (NUM_PITCHES + 1);				// no zero to rewrite				break;			} else {				if (selected[i] == 0) {				zero = i;				// remember index of a 0 to set later.				}			}		}				if ((zero < NUM_PITCHES) && (arguments[1] > 0.)) {			selected[zero] = arguments[0];			// set key of one that is not used			selectedYValue[zero] = (arguments[1] / 127.);			selectPointer = zero;		} else if ((zero == NUM_PITCHES) && (arguments[1] > 0.)) {			selected[selectPointer] = arguments[0];	// none open, set last set to new value			selectedYValue[selectPointer] = (arguments[1] / 127.);		}		bang();	}		if (inlet == 1) {							// **** Set Pitches **** //		for (i = 0; i < NUM_PITCHES; i++) {			selected[i] = Math.round(arguments[i]);		}	}	if (inlet == 2) {							// **** Set Amplitudes **** //		for (i = 0; i < NUM_PITCHES; i++) {			selectedYValue[i] = arguments[i];		}		for (i = 0; i < NUM_PITCHES; i++) {					// send out pitches only after receiving the amplitude list			outlet(0, i, selected[i], selectedYValue[i]);		}			draw();		refresh();		notifyclients();	}	}function fsaa(v){	sketch.fsaa = v;	bang();}function frgb(r,g,b){	vfrgb[0] = r/255.;	vfrgb[1] = g/255.;	vfrgb[2] = b/255.;	draw();	refresh();}function rgb2(r,g,b){	vrgb2[0] = r/255.;	vrgb2[1] = g/255.;	vrgb2[2] = b/255.;	draw();	refresh();}function brgb(r,g,b){	vbrgb[0] = r/255.;	vbrgb[1] = g/255.;	vbrgb[2] = b/255.;	draw();	refresh();}function octaves(v){	if (v < 10) {		numOctaves = v;	} else{		post("must be less than 10 octaves\n");	}	recalculateKeyboard();}function offset(v){	if (v < 49) {		keyOffset = v;	} else {		post("must be less than 49 steps\n");	}	recalculateKeyboard();}function recalculateKeyboard(){	const HIGHEST_PITCH = (keyOffset + (numOctaves * 12));	box.size((img.size[0] * numOctaves),img.size[1]);		// Constrain window to image size		draw();}recalculateKeyboard.local = 1;function flush(){	for (i=0; i < NUM_PITCHES; i++){		selected[i] = 0.;		selectedYValue[i] = 0.;		selectPointer = i;		sendOut();	}		draw();	refresh();}function transpose(v)							// transpose all pitches v # of semitones{	v = Math.floor(v);		for (i=0; i < NUM_PITCHES; i++){			// cycle through all 16 pitches		selected[i] = (selected[i] + v);		// set to the new value		if ((selected[i] >= HIGHEST_PITCH) || (selected[i] < keyOffset)) {		// limit it to lowest pitch < v < highest pitch			selected[i] = 0.;			selectedYValue[i] = 0.;		}		selectPointer = i;		sendOut();	}		draw();	refresh();}function setvalueof(v){	msg_float(v);}function getvalueof(){	var data = new Array();	var dataNum = 0;		data[dataNum++] = KEYSLIDER_VERSION;	for (i=0; i < NUM_PITCHES; i++){		data[dataNum++] = selected[i];		data[dataNum++] = selectedYValue[i];	}			return data;	return numOctaves;}function onclick(x,y,but,cmd,shift,capslock,option,ctrl){	var keyPitchDivisionsA = (img.size[0]/21);		// how many pixels per third of a key	var keyPitchDivisionsB = (img.size[0]/7);	var octaves = 0;								// how many octaves up the click was	var withinOctavePix = 0;						// what pixel within an octave	var pitchSortOf = 0;	var pitch = 0;									// which pitch is selected	var velocity = 0.;		if (y <= BLACK_KEY_PIXEL_HEIGHT) {				// finds which key is clicked		octaves = Math.floor(x / img.size[0]);  // may need -1, this = number of octaves		withinOctavePix = x - (octaves * img.size[0]);  // multiply octaves times number of pixels per octave then subtract the original amount, leaves the pixels within an octave.		pitchSortOf = Math.floor(withinOctavePix / keyPitchDivisionsA);  // find how many thirds of a key the click is.		pitch = (pitchA[pitchSortOf] + (octaves * 12) + keyOffset);	// poll the pitch divisions to find where clicked then add in the octaves & offset.		velocity = (1. - (y / BLACK_KEY_PIXEL_HEIGHT));	} else {		octaves = Math.floor(x / img.size[0]);  // may need -1, this = number of octaves		withinOctavePix = x - (octaves * img.size[0]);  // multiply octaves times number of pixels per octave then subtract the original amount, leaves the pixels within an octave.		pitchSortOf = Math.floor(withinOctavePix / keyPitchDivisionsB);  // find how many keys up the click is.		pitch = (pitchB[pitchSortOf] + (octaves * 12) + keyOffset);	// poll the pitch divisions to find where clicked then add in the octaves & offset.		velocity = (1. - (y / boxHeight));	}		for (i = 0; i < NUM_PITCHES; i++) {		// search 16 selections to see if one is on		if (selected[i] == pitch) {			selected[i] = 0;		// turn it off			selectedYValue[i] = 0.;			selectPointer = i;		// sets last selected to be overwritten if there are no 0's available			zero = 17;				// no zero to rewrite			break;		} else {			if (selected[i] == 0) {			zero = i;				// remember index of a 0 to set later.			}		}	}		if (zero < NUM_PITCHES) {		selected[zero] = pitch;			// set key of one that is not used		selectedYValue[zero] = velocity;		selectPointer = zero;	} else if (zero == NUM_PITCHES) {		selected[selectPointer] = pitch;	// none open, set last set to new value		selectedYValue[selectPointer] = velocity;	}		bang();}onclick.local = 1; //private. could be left public to permit "synthetic" eventsfunction ondrag(x,y,but,cmd,shift,capslock,option,ctrl){/*	var f,a;	a = sketch.screentoworld(x,y);	f = (a[1]+0.8)/1.6; //on screen in range -0.8 to 0.8		msg_float(f); //set new value with clipping + refresh*/}ondrag.local = 1; //private. could be left public to permit "synthetic" eventsfunction onresize(w,h){	box.size((img.size[0] * numOctaves),img.size[1]);		// Constrain window to image size	draw();	refresh();}onresize.local = 1; //private